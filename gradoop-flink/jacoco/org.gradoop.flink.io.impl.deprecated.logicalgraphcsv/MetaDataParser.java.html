<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MetaDataParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Gradoop Flink</a> &gt; <a href="index.source.html" class="el_package">org.gradoop.flink.io.impl.deprecated.logicalgraphcsv</a> &gt; <span class="el_source">MetaDataParser.java</span></div><h1>MetaDataParser.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2014 - 2019 Leipzig University (Database Research Group)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gradoop.flink.io.impl.deprecated.logicalgraphcsv;

import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.api.java.tuple.Tuple3;
import org.gradoop.common.model.impl.id.GradoopId;
import org.gradoop.common.model.impl.properties.Property;
import org.gradoop.common.model.impl.properties.PropertyValue;
import org.gradoop.common.model.impl.metadata.PropertyMetaData;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Responsible for creating a {@link MetaData} instance from its string representation.
 */
@Deprecated
<span class="nc" id="L43">public class MetaDataParser {</span>
  /**
   * Used to separate property meta data.
   */
  private static final String PROPERTY_DELIMITER = &quot;,&quot;;
  /**
   * Used to separate list items
   */
  private static final String LIST_DELIMITER = &quot;, &quot;;
  /**
   * Used to separate property tokens (property-key, property-type)
   */
  private static final String PROPERTY_TOKEN_DELIMITER = &quot;:&quot;;
  /**
   * Used to map a type string to its corresponding parsing function
   */
<span class="fc" id="L59">  private static final Map&lt;String, Function&lt;String, Object&gt;&gt; TYPE_PARSER_MAP = getTypeParserMap();</span>

  /**
   * Creates the type - parser function mapping of static property TYPE_PARSER_MAP
   *
   * @return a HashMap containing the mapping of a type string to its corresponding parsing function
   */
  private static Map&lt;String, Function&lt;String, Object&gt;&gt; getTypeParserMap() {
<span class="fc" id="L67">    Map&lt;String, Function&lt;String, Object&gt;&gt; map = new HashMap&lt;&gt;();</span>
<span class="fc" id="L68">    map.put(TypeString.SHORT.getTypeString(), Short::parseShort);</span>
<span class="fc" id="L69">    map.put(TypeString.INTEGER.getTypeString(), Integer::parseInt);</span>
<span class="fc" id="L70">    map.put(TypeString.LONG.getTypeString(), Long::parseLong);</span>
<span class="fc" id="L71">    map.put(TypeString.FLOAT.getTypeString(), Float::parseFloat);</span>
<span class="fc" id="L72">    map.put(TypeString.DOUBLE.getTypeString(), Double::parseDouble);</span>
<span class="fc" id="L73">    map.put(TypeString.BOOLEAN.getTypeString(), Boolean::parseBoolean);</span>
<span class="fc" id="L74">    map.put(TypeString.STRING.getTypeString(), s -&gt; s);</span>
<span class="fc" id="L75">    map.put(TypeString.BIGDECIMAL.getTypeString(), BigDecimal::new);</span>
<span class="fc" id="L76">    map.put(TypeString.GRADOOPID.getTypeString(), GradoopId::fromString);</span>
<span class="fc" id="L77">    map.put(TypeString.MAP.getTypeString(), MetaDataParser::parseMapProperty);</span>
<span class="fc" id="L78">    map.put(TypeString.LIST.getTypeString(), MetaDataParser::parseListProperty);</span>
<span class="fc" id="L79">    map.put(TypeString.LOCALDATE.getTypeString(), LocalDate::parse);</span>
<span class="fc" id="L80">    map.put(TypeString.LOCALTIME.getTypeString(), LocalTime::parse);</span>
<span class="fc" id="L81">    map.put(TypeString.LOCALDATETIME.getTypeString(), LocalDateTime::parse);</span>
<span class="fc" id="L82">    map.put(TypeString.NULL.getTypeString(), MetaDataParser::parseNullProperty);</span>
<span class="fc" id="L83">    map.put(TypeString.SET.getTypeString(), MetaDataParser::parseSetProperty);</span>
<span class="fc" id="L84">    return Collections.unmodifiableMap(map);</span>
  }

  /**
   * Creates a {@link MetaData} object from the specified lines. The specified tuple is already
   * separated into the label and the
   *
   * @param metaDataStrings (element prefix (g,v,e), label, meta-data) tuples
   * @return Meta Data object
   */
  public static MetaData create(List&lt;Tuple3&lt;String, String, String&gt;&gt; metaDataStrings) {
<span class="fc" id="L95">    Map&lt;Tuple2&lt;String, String&gt;, List&lt;PropertyMetaData&gt;&gt; metaDataMap</span>
<span class="fc" id="L96">      = new HashMap&lt;&gt;(metaDataStrings.size());</span>

<span class="fc bfc" id="L98" title="All 2 branches covered.">    for (Tuple3&lt;String, String, String&gt; tuple : metaDataStrings) {</span>
      List&lt;PropertyMetaData&gt; propertyMetaDataList;
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">      if (tuple.f2.length() &gt; 0) {</span>
<span class="fc" id="L101">        String[] propertyStrings = tuple.f2.split(PROPERTY_DELIMITER);</span>
<span class="fc" id="L102">        propertyMetaDataList = new ArrayList&lt;&gt;(propertyStrings.length);</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">        for (String propertyString : propertyStrings) {</span>
<span class="fc" id="L104">          String[] propertyMetadata = propertyString.split(PROPERTY_TOKEN_DELIMITER, 2);</span>
<span class="fc" id="L105">          String[] propertyTypeTokens = propertyMetadata[1].split(PROPERTY_TOKEN_DELIMITER);</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">          if (propertyTypeTokens.length == 2 &amp;&amp;</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">            propertyTypeTokens[0].equals(TypeString.LIST.getTypeString())) {</span>
            // it's a list with one additional data type (type of list items)
<span class="fc" id="L109">            propertyMetaDataList.add(new PropertyMetaData(</span>
<span class="fc" id="L110">              propertyMetadata[0], propertyMetadata[1], getListValueParser(propertyTypeTokens[1])));</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">          } else if (propertyTypeTokens.length == 2 &amp;&amp;</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">            propertyTypeTokens[0].equals(TypeString.SET.getTypeString())) {</span>
            // it's a set with one additional data type (type of set items)
<span class="fc" id="L114">            propertyMetaDataList.add(new PropertyMetaData(</span>
<span class="fc" id="L115">              propertyMetadata[0], propertyMetadata[1], getSetValueParser(propertyTypeTokens[1])));</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">          } else if (propertyTypeTokens.length == 3 &amp;&amp;</span>
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">            propertyTypeTokens[0].equals(TypeString.MAP.getTypeString())) {</span>
            // it's a map with two additional data types (key type + value type)
<span class="fc" id="L119">            propertyMetaDataList.add(</span>
              new PropertyMetaData(
                propertyMetadata[0],
                propertyMetadata[1],
<span class="fc" id="L123">                getMapValueParser(propertyTypeTokens[1], propertyTypeTokens[2])</span>
              )
            );
          } else {
<span class="fc" id="L127">            propertyMetaDataList.add(new PropertyMetaData(</span>
<span class="fc" id="L128">              propertyMetadata[0], propertyMetadata[1], getValueParser(propertyMetadata[1])));</span>
          }
        }
<span class="fc" id="L131">      } else {</span>
<span class="nc" id="L132">        propertyMetaDataList = new ArrayList&lt;&gt;(0);</span>
      }
<span class="fc" id="L134">      metaDataMap.put(new Tuple2&lt;&gt;(tuple.f0, tuple.f1), propertyMetaDataList);</span>
<span class="fc" id="L135">    }</span>

<span class="fc" id="L137">    return new MetaData(metaDataMap);</span>
  }

  /**
   * Returns the property meta data string for the specified property. The string consists of the
   * property key and the property value type, e.g. &quot;foo:int&quot;.
   *
   * @param property property
   * @return property meta data
   */
  public static String getPropertyMetaData(Property property) {
<span class="nc" id="L148">    return String.format(&quot;%s%s%s&quot;,</span>
<span class="nc" id="L149">      property.getKey(), PROPERTY_TOKEN_DELIMITER, getTypeString(property.getValue()));</span>
  }

  /**
   * Sorts and concatenates the specified meta data entries.
   *
   * @param propertyMetaDataSet set of property meta data strings
   * @return sorted and concatenated string
   */
  public static String getPropertiesMetaData(Set&lt;String&gt; propertyMetaDataSet) {
<span class="nc" id="L159">    return propertyMetaDataSet.stream()</span>
<span class="nc" id="L160">      .sorted()</span>
<span class="nc" id="L161">      .collect(Collectors.joining(PROPERTY_DELIMITER));</span>
  }

  /**
   * Creates a parsing function for the given property type.
   *
   * @param type property type
   * @return parsing function
   */
  private static Function&lt;String, Object&gt; getValueParser(String type) {
<span class="fc" id="L171">    type = type.toLowerCase();</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">    if (TYPE_PARSER_MAP.containsKey(type)) {</span>
<span class="fc" id="L173">      return TYPE_PARSER_MAP.get(type);</span>
    } else {
<span class="nc" id="L175">      throw new IllegalArgumentException(&quot;Type &quot; + type + &quot; is not supported&quot;);</span>
    }
  }

  /**
   * Creates a parsing function for list property type.
   *
   * @param listItemType string representation of the list item type, e.g. &quot;String&quot;
   * @return parsing function
   */
  private static Function&lt;String, Object&gt; getListValueParser(String listItemType) {
<span class="fc" id="L186">    final String itemType = listItemType.toLowerCase();</span>
    // check the validity of the list item type
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">    if (!TYPE_PARSER_MAP.containsKey(itemType)) {</span>
<span class="nc" id="L189">      throw new TypeNotPresentException(itemType, null);</span>
    }

<span class="fc" id="L192">    return s -&gt; parseListProperty(s, TYPE_PARSER_MAP.get(itemType));</span>
  }

  /**
   * Creates a parsing function for map property type.
   *
   * @param keyType string representation of the map key type, e.g. &quot;String&quot;
   * @param valueType string representation of the map value type, e.g. &quot;Double&quot;
   * @return parsing function
   */
  private static Function&lt;String, Object&gt; getMapValueParser(String keyType, String valueType) {
<span class="fc" id="L203">    final String keyTypeLowerCase = keyType.toLowerCase();</span>
    // check the validity of the map key type
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">    if (!TYPE_PARSER_MAP.containsKey(keyTypeLowerCase)) {</span>
<span class="nc" id="L206">      throw new TypeNotPresentException(keyTypeLowerCase, null);</span>
    }

<span class="fc" id="L209">    final String valueTypeLowerCase = valueType.toLowerCase();</span>
    // check the validity of the map value type
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">    if (!TYPE_PARSER_MAP.containsKey(valueTypeLowerCase)) {</span>
<span class="nc" id="L212">      throw new TypeNotPresentException(keyTypeLowerCase, null);</span>
    }

<span class="fc" id="L215">    return s -&gt; parseMapProperty(</span>
      s,
<span class="fc" id="L217">      TYPE_PARSER_MAP.get(keyTypeLowerCase),</span>
<span class="fc" id="L218">      TYPE_PARSER_MAP.get(valueTypeLowerCase)</span>
    );
  }

  /**
   * Creates a parsing function for set property type.
   *
   * @param setItemType string representation of the set item type, e.g. &quot;String&quot;
   * @return parsing function
   */
  private static Function&lt;String, Object&gt; getSetValueParser(String setItemType) {
<span class="fc" id="L229">    final String itemType = setItemType.toLowerCase();</span>
    // check the validity of the set item type
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">    if (!TYPE_PARSER_MAP.containsKey(itemType)) {</span>
<span class="nc" id="L232">      throw new TypeNotPresentException(itemType, null);</span>
    }

<span class="fc" id="L235">    return s -&gt; parseSetProperty(s, TYPE_PARSER_MAP.get(itemType));</span>
  }
  /**
   * Parse function to translate string representation of a List to a list of PropertyValues
   * Every PropertyValue has the type &quot;string&quot;, because there is no parser for the items given
   * Use {@link #parseListProperty(String, Function)} to specify a parsing function
   *
   * @param s the string to parse as list, e.g. &quot;[myString1, myString2]&quot;
   * @return the list represented by the argument
   */
  private static Object parseListProperty(String s) {
    // no item type given, so use string as type
<span class="nc" id="L247">    s = s.replace(&quot;[&quot;, &quot;&quot;).replace(&quot;]&quot;, &quot;&quot;);</span>
<span class="nc" id="L248">    return Arrays.stream(s.split(LIST_DELIMITER))</span>
<span class="nc" id="L249">      .map(PropertyValue::create)</span>
<span class="nc" id="L250">      .collect(Collectors.toList());</span>
  }

  /**
   * Parse function to translate string representation of a List to a list of PropertyValues
   *
   * @param s the string to parse as list, e.g. &quot;[myString1, myString2]&quot;
   * @param itemParser the function to parse the list items
   * @return the list represented by the argument
   */
  private static Object parseListProperty(String s, Function&lt;String, Object&gt; itemParser) {
<span class="fc" id="L261">    s = s.replace(&quot;[&quot;, &quot;&quot;).replace(&quot;]&quot;, &quot;&quot;);</span>
<span class="fc" id="L262">    return Arrays.stream(s.split(LIST_DELIMITER))</span>
<span class="fc" id="L263">      .map(itemParser)</span>
<span class="fc" id="L264">      .map(PropertyValue::create)</span>
<span class="fc" id="L265">      .collect(Collectors.toList());</span>
  }

  /**
   * Parse function to translate string representation of a Map to a Map with key and value of
   * type PropertyValue. Every PropertyValue (key and value) has the type &quot;string&quot;, because there
   * are no parsers for the keys and values given. Use
   * {@link #parseMapProperty(String, Function, Function)} to specify both parsing functions.
   *
   * @param s the string to parse as map, e.g. &quot;{myString1=myValue1, myString2=myValue2}&quot;
   * @return the map represented by the argument
   */
  private static Object parseMapProperty(String s) {
    // no key type and value type given, so use string as types
<span class="nc" id="L279">    s = s.replace(&quot;{&quot;, &quot;&quot;).replace(&quot;}&quot;, &quot;&quot;);</span>
<span class="nc" id="L280">    return Arrays.stream(s.split(LIST_DELIMITER))</span>
<span class="nc" id="L281">      .map(st -&gt; st.split(&quot;=&quot;))</span>
<span class="nc" id="L282">      .collect(Collectors.toMap(e -&gt; PropertyValue.create(e[0]), e -&gt; PropertyValue.create(e[1])));</span>
  }

  /**
   * Parse function to translate string representation of a Map to a Map with
   * key and value of type PropertyValue
   *
   * @param s the string to parse as map, e.g. &quot;{myString1=myValue1, myString2=myValue2}&quot;
   * @param keyParser the function to parse the keys
   * @param valueParser the function to parse the values
   * @return the map represented by the argument
   */
  private static Object parseMapProperty(
    String s,
    Function&lt;String, Object&gt; keyParser,
    Function&lt;String, Object&gt; valueParser
  ) {
<span class="fc" id="L299">    s = s.replace(&quot;{&quot;, &quot;&quot;).replace(&quot;}&quot;, &quot;&quot;);</span>
<span class="fc" id="L300">    return Arrays.stream(s.split(LIST_DELIMITER))</span>
<span class="fc" id="L301">      .map(st -&gt; st.split(&quot;=&quot;))</span>
<span class="fc" id="L302">      .map(strings -&gt; {</span>
<span class="fc" id="L303">        Object[] objects = new Object[2];</span>
<span class="fc" id="L304">        objects[0] = keyParser.apply(strings[0]);</span>
<span class="fc" id="L305">        objects[1] = valueParser.apply(strings[1]);</span>
<span class="fc" id="L306">        return objects;</span>
      })
<span class="fc" id="L308">      .collect(Collectors.toMap(e -&gt; PropertyValue.create(e[0]), e -&gt; PropertyValue.create(e[1])));</span>
  }

  /**
   * Parse function to translate string representation of a Set to a set of PropertyValues
   * Every PropertyValue has the type &quot;string&quot;, because there is no parser for the items given
   * Use {@link #parseListProperty(String, Function)} to specify a parsing function
   *
   * @param s the string to parse as set, e.g. &quot;[myString1, myString2]&quot;
   * @return the set represented by the argument
   */
  private static Object parseSetProperty(String s) {
    // no item type given, so use string as type
<span class="nc" id="L321">    s = s.replace(&quot;[&quot;, &quot;&quot;).replace(&quot;]&quot;, &quot;&quot;);</span>
<span class="nc" id="L322">    return Arrays.stream(s.split(LIST_DELIMITER))</span>
<span class="nc" id="L323">      .map(PropertyValue::create)</span>
<span class="nc" id="L324">      .collect(Collectors.toSet());</span>
  }

  /**
   * Parse function to translate string representation of a Set to a set of PropertyValues
   *
   * @param s the string to parse as set, e.g. &quot;[myString1, myString2]&quot;
   * @param itemParser the function to parse the set items
   * @return the set represented by the argument
   */
  private static Object parseSetProperty(String s, Function&lt;String, Object&gt; itemParser) {
<span class="fc" id="L335">    s = s.replace(&quot;[&quot;, &quot;&quot;).replace(&quot;]&quot;, &quot;&quot;);</span>
<span class="fc" id="L336">    return Arrays.stream(s.split(LIST_DELIMITER))</span>
<span class="fc" id="L337">      .map(itemParser)</span>
<span class="fc" id="L338">      .map(PropertyValue::create)</span>
<span class="fc" id="L339">      .collect(Collectors.toSet());</span>
  }
  /**
   * Parse function to create null from the null string representation.
   *
   * @param nullString The string representing null.
   * @throws IllegalArgumentException The string that is passed has to represent null.
   * @return Returns null
   */
  private static Object parseNullProperty(String nullString) throws IllegalArgumentException {
<span class="pc bpc" id="L349" title="2 of 4 branches missed.">    if (nullString != null &amp;&amp; nullString.equalsIgnoreCase(TypeString.NULL.getTypeString())) {</span>
<span class="fc" id="L350">      return null;</span>
    } else {
<span class="nc" id="L352">      throw new IllegalArgumentException(&quot;Only null represents a null string.&quot;);</span>
    }
  }

  /**
   * Returns the type string for the specified property value.
   *
   * @param propertyValue property value
   * @return property type string
   */
  public static String getTypeString(PropertyValue propertyValue) {
<span class="nc bnc" id="L363" title="All 2 branches missed.">    if (propertyValue.isNull()) {</span>
<span class="nc" id="L364">      return TypeString.NULL.getTypeString();</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">    } else if (propertyValue.isShort()) {</span>
<span class="nc" id="L366">      return TypeString.SHORT.getTypeString();</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">    } else if (propertyValue.isInt()) {</span>
<span class="nc" id="L368">      return TypeString.INTEGER.getTypeString();</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">    } else if (propertyValue.isLong()) {</span>
<span class="nc" id="L370">      return TypeString.LONG.getTypeString();</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">    } else if (propertyValue.isFloat()) {</span>
<span class="nc" id="L372">      return TypeString.FLOAT.getTypeString();</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">    } else if (propertyValue.isDouble()) {</span>
<span class="nc" id="L374">      return TypeString.DOUBLE.getTypeString();</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">    } else if (propertyValue.isBoolean()) {</span>
<span class="nc" id="L376">      return TypeString.BOOLEAN.getTypeString();</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">    } else if (propertyValue.isString()) {</span>
<span class="nc" id="L378">      return TypeString.STRING.getTypeString();</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">    } else if (propertyValue.isBigDecimal()) {</span>
<span class="nc" id="L380">      return TypeString.BIGDECIMAL.getTypeString();</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">    } else if (propertyValue.isGradoopId()) {</span>
<span class="nc" id="L382">      return TypeString.GRADOOPID.getTypeString();</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">    } else if (propertyValue.isMap()) {</span>
      // map type string is map:{keyType}:{valueType}
<span class="nc" id="L385">      return TypeString.MAP.getTypeString() +</span>
        PROPERTY_TOKEN_DELIMITER +
<span class="nc" id="L387">        getTypeString(propertyValue.getMap().keySet().iterator().next()) +</span>
        PROPERTY_TOKEN_DELIMITER +
<span class="nc" id="L389">        getTypeString(propertyValue.getMap().values().iterator().next());</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">    } else if (propertyValue.isList()) {</span>
      // list type string is list:{itemType}
<span class="nc" id="L392">      return TypeString.LIST.getTypeString() +</span>
        PROPERTY_TOKEN_DELIMITER +
<span class="nc" id="L394">        getTypeString(propertyValue.getList().get(0));</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">    } else if (propertyValue.isDate()) {</span>
<span class="nc" id="L396">      return TypeString.LOCALDATE.getTypeString();</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">    } else if (propertyValue.isTime()) {</span>
<span class="nc" id="L398">      return TypeString.LOCALTIME.getTypeString();</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">    } else if (propertyValue.isDateTime()) {</span>
<span class="nc" id="L400">      return TypeString.LOCALDATETIME.getTypeString();</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">    } else if (propertyValue.isSet()) {</span>
      // set type string is set:{itemType}
<span class="nc" id="L403">      return TypeString.SET.getTypeString() +</span>
        PROPERTY_TOKEN_DELIMITER +
<span class="nc" id="L405">        getTypeString(propertyValue.getSet().iterator().next());</span>
    } else {
<span class="nc" id="L407">      throw new IllegalArgumentException(&quot;Type &quot; + propertyValue.getType() + &quot; is not supported&quot;);</span>
    }
  }

  /**
   * Supported type strings for the CSV format.
   */
<span class="fc" id="L414">  private enum TypeString {</span>
    /**
     * Null type
     */
<span class="fc" id="L418">    NULL(&quot;null&quot;),</span>
    /**
     * Boolean type
     */
<span class="fc" id="L422">    BOOLEAN(&quot;boolean&quot;),</span>
    /**
     * Short type
     */
<span class="fc" id="L426">    SHORT(&quot;short&quot;),</span>
    /**
     * Integer type
     */
<span class="fc" id="L430">    INTEGER(&quot;int&quot;),</span>
    /**
     * Long type
     */
<span class="fc" id="L434">    LONG(&quot;long&quot;),</span>
    /**
     * Float type
     */
<span class="fc" id="L438">    FLOAT(&quot;float&quot;),</span>
    /**
     * Double type
     */
<span class="fc" id="L442">    DOUBLE(&quot;double&quot;),</span>
    /**
     * String type
     */
<span class="fc" id="L446">    STRING(&quot;string&quot;),</span>
    /**
     * BigDecimal type
     */
<span class="fc" id="L450">    BIGDECIMAL(&quot;bigdecimal&quot;),</span>
    /**
     * GradoopId type
     */
<span class="fc" id="L454">    GRADOOPID(&quot;gradoopid&quot;),</span>
    /**
     * Map type
     */
<span class="fc" id="L458">    MAP(&quot;map&quot;),</span>
    /**
     * List type
     */
<span class="fc" id="L462">    LIST(&quot;list&quot;),</span>
    /**
     * LocalDate type
     */
<span class="fc" id="L466">    LOCALDATE(&quot;localdate&quot;),</span>
    /**
     * LocalTime type
     */
<span class="fc" id="L470">    LOCALTIME(&quot;localtime&quot;),</span>
    /**
     * LocalDateTime type
     */
<span class="fc" id="L474">    LOCALDATETIME(&quot;localdatetime&quot;),</span>
    /**
     * Set type
     */
<span class="fc" id="L478">    SET(&quot;set&quot;);</span>

    /**
     * String representation
     */
    private String typeString;

    /**
     * Constructor
     *
     * @param typeString string representation
     */
<span class="fc" id="L490">    TypeString(String typeString) {</span>
<span class="fc" id="L491">      this.typeString = typeString;</span>
<span class="fc" id="L492">    }</span>

    /**
     * Returns the type string
     *
     * @return type string
     */
    public String getTypeString() {
<span class="fc" id="L500">      return typeString;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>