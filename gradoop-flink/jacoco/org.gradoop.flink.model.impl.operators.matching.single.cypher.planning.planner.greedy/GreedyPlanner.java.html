<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GreedyPlanner.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Gradoop Flink</a> &gt; <a href="index.source.html" class="el_package">org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.planner.greedy</a> &gt; <span class="el_source">GreedyPlanner.java</span></div><h1>GreedyPlanner.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2014 - 2019 Leipzig University (Database Research Group)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.planner.greedy;

import com.google.common.collect.Sets;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.flink.api.java.DataSet;
import org.gradoop.common.util.GradoopConstants;
import org.gradoop.flink.model.impl.epgm.LogicalGraph;
import org.gradoop.flink.model.impl.operators.matching.common.MatchStrategy;
import org.gradoop.flink.model.impl.operators.matching.common.query.QueryHandler;
import org.gradoop.flink.model.impl.operators.matching.common.query.predicates.CNF;
import org.gradoop.flink.model.impl.operators.matching.common.query.predicates.CNFElement;
import org.gradoop.flink.model.impl.operators.matching.common.query.predicates.QueryComparable;
import org.gradoop.flink.model.impl.operators.matching.common.query.predicates.comparables.PropertySelectorComparable;
import org.gradoop.flink.model.impl.operators.matching.common.query.predicates.expressions.ComparisonExpression;
import org.gradoop.flink.model.impl.operators.matching.common.statistics.GraphStatistics;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.utils.ExpandDirection;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.estimation.QueryPlanEstimator;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.plantable.PlanTable;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.plantable.PlanTableEntry;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.PlanNode;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.QueryPlan;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.binary.CartesianProductNode;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.binary.ExpandEmbeddingsNode;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.binary.JoinEmbeddingsNode;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.binary.ValueJoinNode;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.leaf.FilterAndProjectEdgesNode;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.leaf.FilterAndProjectVerticesNode;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.unary.FilterEmbeddingsNode;
import org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.queryplan.unary.ProjectEmbeddingsNode;
import org.s1ck.gdl.model.Edge;
import org.s1ck.gdl.model.Vertex;
import org.s1ck.gdl.utils.Comparator;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import static org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.plantable.PlanTableEntry.Type.EDGE;
import static org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.plantable.PlanTableEntry.Type.GRAPH;
import static org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.plantable.PlanTableEntry.Type.PATH;
import static org.gradoop.flink.model.impl.operators.matching.single.cypher.planning.plantable.PlanTableEntry.Type.VERTEX;

/**
 * A greedy query planner that builds a query plan by iteratively picking the cheapest partial query
 * plan and extending it.
 */
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">public class GreedyPlanner {</span>
  /**
   * The search graph to be queried
   */
  private final LogicalGraph graph;
  /**
   * The query handler represents the query.
   */
  private final QueryHandler queryHandler;
  /**
   * Statistics about the search graph.
   */
  private final GraphStatistics graphStatistics;
  /**
   * The morphism type for vertex mappings.
   */
  private final MatchStrategy vertexStrategy;
  /**
   * The morphism type for edge mappings.
   */
  private final MatchStrategy edgeStrategy;

  /**
   * Creates a new greedy planner.
   *
   * @param graph search graph
   * @param queryHandler query handler
   * @param graphStatistics search graph statistics
   * @param vertexStrategy morphism type for vertex mappings
   * @param edgeStrategy morphism type for edge mappings
   */
  public GreedyPlanner(LogicalGraph graph, QueryHandler queryHandler,
<span class="fc" id="L96">    GraphStatistics graphStatistics, MatchStrategy vertexStrategy, MatchStrategy edgeStrategy) {</span>
<span class="fc" id="L97">    this.graph = graph;</span>
<span class="fc" id="L98">    this.queryHandler = queryHandler;</span>
<span class="fc" id="L99">    this.graphStatistics = graphStatistics;</span>
<span class="fc" id="L100">    this.vertexStrategy = vertexStrategy;</span>
<span class="fc" id="L101">    this.edgeStrategy = edgeStrategy;</span>
<span class="fc" id="L102">  }</span>

  /**
   * Computes the {@link PlanTableEntry} that wraps the {@link QueryPlan} with the minimum costs
   * according to the greedy optimization algorithm.
   *
   * @return entry with minimum execution costs
   */
  public PlanTableEntry plan() {
<span class="fc" id="L111">    PlanTable planTable = initPlanTable();</span>

<span class="fc bfc" id="L113" title="All 2 branches covered.">    while (planTable.size() &gt; 1) {</span>
<span class="fc" id="L114">      PlanTable newPlans = evaluateJoins(planTable);</span>

<span class="fc bfc" id="L116" title="All 2 branches covered.">      if (newPlans.size() == 0) {</span>
        // No new plans where generated by joining but there are still multiple disconnected
        // query graph components. In this case we need to do a cartesian product.
<span class="fc" id="L119">        newPlans = evaluateCartesianProducts(planTable);</span>
      }
<span class="fc" id="L121">      newPlans = evaluateFilter(newPlans);</span>
<span class="fc" id="L122">      newPlans = evaluateProjection(newPlans);</span>

      // get plan with minimum costs and remove all plans covered by this plan
<span class="fc" id="L125">      PlanTableEntry bestEntry = newPlans.min();</span>
<span class="fc" id="L126">      planTable.removeCoveredBy(bestEntry);</span>
<span class="fc" id="L127">      planTable.add(bestEntry);</span>
<span class="fc" id="L128">    }</span>

<span class="fc" id="L130">    return planTable.get(0);</span>
  }

  //------------------------------------------------------------------------------------------------
  // Initialization
  //------------------------------------------------------------------------------------------------

  /**
   * Creates the initial plan table entries according to the specified vertices and edges.
   *
   * @return initial plan table
   */
  private PlanTable initPlanTable() {
<span class="fc" id="L143">    PlanTable planTable = new PlanTable();</span>
<span class="fc" id="L144">    createVertexPlans(planTable);</span>
<span class="fc" id="L145">    createEdgePlans(planTable);</span>
<span class="fc" id="L146">    return planTable;</span>
  }

  //------------------------------------------------------------------------------------------------
  // Leaf nodes (i.e. vertices and (variable length) edges)
  //------------------------------------------------------------------------------------------------

  /**
   * Creates an initial {@link PlanTableEntry} for each vertex in the query graph and adds it to the
   * specified {@link PlanTable}. The entry wraps a query plan that filters vertices based on their
   * predicates and projects properties that are required for further query planning.
   *
   * @param planTable plan table
   */
  private void createVertexPlans(PlanTable planTable) {
<span class="fc bfc" id="L161" title="All 2 branches covered.">    for (Vertex vertex : queryHandler.getVertices()) {</span>
<span class="fc" id="L162">      String vertexVariable = vertex.getVariable();</span>
<span class="fc" id="L163">      CNF allPredicates = queryHandler.getPredicates();</span>
      // TODO: this might be moved to the FilterAndProject node in issue #510
<span class="fc" id="L165">      CNF vertexPredicates = allPredicates.removeSubCNF(vertexVariable);</span>
<span class="fc" id="L166">      Set&lt;String&gt; projectionKeys = allPredicates.getPropertyKeys(vertexVariable);</span>

<span class="fc" id="L168">      DataSet&lt;org.gradoop.common.model.impl.pojo.Vertex&gt; vertices =</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        vertex.getLabel().equals(GradoopConstants.DEFAULT_VERTEX_LABEL) ?</span>
<span class="fc" id="L170">          graph.getVertices() : graph.getVerticesByLabel(vertex.getLabel());</span>

<span class="fc" id="L172">      FilterAndProjectVerticesNode node = new FilterAndProjectVerticesNode(vertices,</span>
<span class="fc" id="L173">        vertex.getVariable(), vertexPredicates, projectionKeys);</span>

<span class="fc" id="L175">      planTable.add(new PlanTableEntry(VERTEX, Sets.newHashSet(vertexVariable), allPredicates,</span>
        new QueryPlanEstimator(new QueryPlan(node), queryHandler, graphStatistics)));
<span class="fc" id="L177">    }</span>
<span class="fc" id="L178">  }</span>

  /**
   * Creates an initial {@link PlanTableEntry} for each edge in the query graph and adds it to the
   * specified {@link PlanTable}. The entry wraps a {@link QueryPlan} that filters edges based on
   * their predicates and projects properties that are required for further query planning.
   *
   * @param planTable plan table
   */
  private void createEdgePlans(PlanTable planTable) {
<span class="fc bfc" id="L188" title="All 2 branches covered.">    for (Edge edge : queryHandler.getEdges()) {</span>
<span class="fc" id="L189">      String edgeVariable = edge.getVariable();</span>
<span class="fc" id="L190">      String sourceVariable = queryHandler.getVertexById(edge.getSourceVertexId()).getVariable();</span>
<span class="fc" id="L191">      String targetVariable = queryHandler.getVertexById(edge.getTargetVertexId()).getVariable();</span>

<span class="fc" id="L193">      CNF allPredicates = queryHandler.getPredicates();</span>
      // TODO: this might be moved the the FilterAndProject node in issue #510
<span class="fc" id="L195">      CNF edgePredicates = allPredicates.removeSubCNF(edgeVariable);</span>
<span class="fc" id="L196">      Set&lt;String&gt; projectionKeys = allPredicates.getPropertyKeys(edgeVariable);</span>

<span class="fc bfc" id="L198" title="All 2 branches covered.">      boolean isPath = edge.getUpperBound() != 1;</span>

<span class="fc" id="L200">      DataSet&lt;org.gradoop.common.model.impl.pojo.Edge&gt; edges =</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">        edge.getLabel().equals(GradoopConstants.DEFAULT_EDGE_LABEL) ?</span>
<span class="fc" id="L202">          graph.getEdges() : graph.getEdgesByLabel(edge.getLabel());</span>

<span class="fc" id="L204">      FilterAndProjectEdgesNode node = new FilterAndProjectEdgesNode(edges,</span>
        sourceVariable, edgeVariable, targetVariable, edgePredicates, projectionKeys, isPath);

<span class="fc bfc" id="L207" title="All 2 branches covered.">      PlanTableEntry.Type type = edge.hasVariableLength() ? PATH : EDGE;</span>

<span class="fc" id="L209">      planTable.add(new PlanTableEntry(type, Sets.newHashSet(edgeVariable), allPredicates,</span>
        new QueryPlanEstimator(new QueryPlan(node), queryHandler, graphStatistics)));
<span class="fc" id="L211">    }</span>
<span class="fc" id="L212">  }</span>

  //------------------------------------------------------------------------------------------------
  // Join and Expand
  //------------------------------------------------------------------------------------------------

  /**
   * Evaluates which entries in the specified plan table can be joined. The joined entries
   * are added to a new table which is returned.
   *
   * @param currentTable query plan table
   * @return new table containing solely joined plans from the input table
   */
  private PlanTable evaluateJoins(PlanTable currentTable) {
<span class="fc" id="L226">    PlanTable newTable = new PlanTable();</span>

<span class="fc bfc" id="L228" title="All 2 branches covered.">    for (int i = 0; i &lt; currentTable.size(); i++) {</span>
<span class="fc" id="L229">      PlanTableEntry leftEntry = currentTable.get(i);</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">      if (mayExtend(leftEntry)) {</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">        for (int j = 0; j &lt; currentTable.size(); j++) {</span>
<span class="fc" id="L232">          PlanTableEntry rightEntry = currentTable.get(j);</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">          if (i != j) {</span>
<span class="fc" id="L234">            List&lt;String&gt; joinVariables = getOverlap(leftEntry, rightEntry);</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">            if (joinVariables.size() &gt; 0) {</span>
<span class="pc bpc" id="L236" title="1 of 4 branches missed.">              if (rightEntry.getType() == PATH &amp;&amp; joinVariables.size() == 2) {</span>
                // evaluate join with variable length path on source and target vertex
<span class="nc" id="L238">                newTable.add(joinEntries(leftEntry, rightEntry, joinVariables.subList(0, 1)));</span>
<span class="nc" id="L239">                newTable.add(joinEntries(leftEntry, rightEntry, joinVariables.subList(1, 2)));</span>
              } else {
                // regular join or join with variable length path on source or target vertex
<span class="fc" id="L242">                newTable.add(joinEntries(leftEntry, rightEntry, joinVariables));</span>
              }
            }
          }
        }
      }
    }
<span class="fc" id="L249">    return newTable;</span>
  }

  /**
   * Checks if the given entry may be extended. This is only the case for entries that represents
   * either a vertex or a partial match graph.
   *
   * @param entry plan table entry
   * @return true, iff the specified entry may be extended
   */
  private boolean mayExtend(PlanTableEntry entry) {
<span class="fc bfc" id="L260" title="All 4 branches covered.">    return entry.getType() == VERTEX || entry.getType() == GRAPH;</span>
  }

  /**
   * Computes the overlapping query variables of the specified entries.
   *
   * @param firstEntry first entry
   * @param secondEntry second entry
   * @return variables that are available in both input entries
   */
  private List&lt;String&gt; getOverlap(PlanTableEntry firstEntry, PlanTableEntry secondEntry) {
<span class="fc" id="L271">    Set&lt;String&gt; overlap = firstEntry.getAllVariables();</span>
<span class="fc" id="L272">    overlap.retainAll(secondEntry.getAllVariables());</span>
<span class="fc" id="L273">    return new ArrayList&lt;&gt;(overlap);</span>
  }

  /**
   * Joins the query plans represented by the specified plan table entries.
   *
   * The method considers if the right entry is a variable length path and in that case
   * creates an {@link ExpandEmbeddingsNode}. In any other case, a regular
   * {@link JoinEmbeddingsNode} is used to join the query plans.
   *
   * @param leftEntry left entry
   * @param rightEntry right entry
   * @param joinVariables join variables
   * @return an entry that represents the join of both input entries
   */
  private PlanTableEntry joinEntries(PlanTableEntry leftEntry, PlanTableEntry rightEntry,
    List&lt;String&gt; joinVariables) {

    PlanNode node;
<span class="fc bfc" id="L292" title="All 2 branches covered.">    if (rightEntry.getType() == PATH) {</span>
<span class="pc bpc" id="L293" title="2 of 4 branches missed.">      assert joinVariables.size() == 1;</span>
<span class="fc" id="L294">      node = createExpandNode(leftEntry, rightEntry, joinVariables.get(0));</span>
    } else {
<span class="fc" id="L296">      node = new JoinEmbeddingsNode(leftEntry.getQueryPlan().getRoot(),</span>
<span class="fc" id="L297">        rightEntry.getQueryPlan().getRoot(), joinVariables, vertexStrategy, edgeStrategy);</span>
    }

    // update processed variables
<span class="fc" id="L301">    HashSet&lt;String&gt; processedVariables = Sets.newHashSet(leftEntry.getProcessedVariables());</span>
<span class="fc" id="L302">    processedVariables.addAll(rightEntry.getProcessedVariables());</span>
    // create resulting predicates
    // TODO: this might be moved to the join/expand node in issue #510
<span class="fc" id="L305">    CNF predicates = mergePredicates(leftEntry, rightEntry);</span>

<span class="fc" id="L307">    return new PlanTableEntry(GRAPH, processedVariables, predicates,</span>
      new QueryPlanEstimator(new QueryPlan(node), queryHandler, graphStatistics));
  }

  /**
   * Creates an {@link ExpandEmbeddingsNode} from the specified arguments.
   *
   * @param leftEntry left entry
   * @param rightEntry right entry
   * @param startVariable vertex variable to expand from
   *
   * @return new expand node
   */
  private ExpandEmbeddingsNode createExpandNode(PlanTableEntry leftEntry, PlanTableEntry rightEntry,
    String startVariable) {

<span class="fc" id="L323">    String pathVariable = rightEntry.getQueryPlan().getRoot()</span>
<span class="fc" id="L324">      .getEmbeddingMetaData().getEdgeVariables().get(0);</span>

<span class="fc" id="L326">    Edge queryEdge = queryHandler.getEdgeByVariable(pathVariable);</span>
<span class="fc" id="L327">    Vertex sourceVertex = queryHandler.getVertexById(queryEdge.getSourceVertexId());</span>
<span class="fc" id="L328">    Vertex targetVertex = queryHandler.getVertexById(queryEdge.getTargetVertexId());</span>

<span class="fc" id="L330">    int lowerBound = queryEdge.getLowerBound();</span>
<span class="fc" id="L331">    int upperBound = queryEdge.getUpperBound();</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">    ExpandDirection direction = sourceVertex.getVariable().equals(startVariable) ?</span>
      ExpandDirection.OUT : ExpandDirection.IN;
<span class="fc bfc" id="L334" title="All 2 branches covered.">    String endVariable = direction == ExpandDirection.OUT ?</span>
<span class="fc" id="L335">      targetVertex.getVariable() : sourceVertex.getVariable();</span>

<span class="fc" id="L337">    return new ExpandEmbeddingsNode(leftEntry.getQueryPlan().getRoot(),</span>
<span class="fc" id="L338">      rightEntry.getQueryPlan().getRoot(),</span>
      startVariable, pathVariable, endVariable, lowerBound, upperBound, direction,
      vertexStrategy, edgeStrategy);
  }

  //------------------------------------------------------------------------------------------------
  // Filter embedding evaluation
  //------------------------------------------------------------------------------------------------

  /**
   * The method checks if a filter can be applied on any of the entries in the specified table. If
   * this is the case, a {@link FilterEmbeddingsNode} is added to the query plan represented by the
   * affected entries.
   *
   * @param currentTable query plan table
   * @return input table with possibly updated entries
   */
  private PlanTable evaluateFilter(PlanTable currentTable) {
<span class="fc" id="L356">    PlanTable newTable = new PlanTable();</span>

<span class="fc bfc" id="L358" title="All 2 branches covered.">    for (PlanTableEntry entry : currentTable) {</span>
<span class="fc" id="L359">      Set&lt;String&gt; variables = Sets.newHashSet(entry.getProcessedVariables());</span>
<span class="fc" id="L360">      CNF predicates = entry.getPredicates();</span>
<span class="fc" id="L361">      CNF subCNF = predicates.removeSubCNF(variables);</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">      if (subCNF.size() &gt; 0) {</span>
<span class="fc" id="L363">        FilterEmbeddingsNode node = new FilterEmbeddingsNode(entry.getQueryPlan().getRoot(),</span>
          subCNF);
<span class="fc" id="L365">        newTable.add(new PlanTableEntry(GRAPH, Sets.newHashSet(entry.getProcessedVariables()),</span>
          predicates, new QueryPlanEstimator(new QueryPlan(node), queryHandler, graphStatistics)));
<span class="fc" id="L367">      } else {</span>
<span class="fc" id="L368">        newTable.add(entry);</span>
      }
<span class="fc" id="L370">    }</span>

<span class="fc" id="L372">    return newTable;</span>
  }

  //------------------------------------------------------------------------------------------------
  // Filter embedding evaluation
  //------------------------------------------------------------------------------------------------

  /**
   * The method checks if a filter can be applied on any of the entries in the specified table. If
   * this is the case, a {@link ProjectEmbeddingsNode} is added to the query plan represented by the
   * affected entries.
   *
   * @param currentTable query plan table
   * @return input table with possibly updated entries
   */
  private PlanTable evaluateProjection(PlanTable currentTable) {
<span class="fc" id="L388">    PlanTable newTable = new PlanTable();</span>

<span class="fc bfc" id="L390" title="All 2 branches covered.">    for (PlanTableEntry entry : currentTable) {</span>
<span class="fc" id="L391">      Set&lt;Pair&lt;String, String&gt;&gt; propertyPairs = entry.getPropertyPairs();</span>
<span class="fc" id="L392">      Set&lt;Pair&lt;String, String&gt;&gt; projectionPairs = entry.getProjectionPairs();</span>

<span class="fc" id="L394">      Set&lt;Pair&lt;String, String&gt;&gt; updatedPropertyPairs = propertyPairs.stream()</span>
<span class="fc" id="L395">        .filter(projectionPairs::contains)</span>
<span class="fc" id="L396">        .collect(Collectors.toSet());</span>

<span class="fc bfc" id="L398" title="All 2 branches covered.">      if (updatedPropertyPairs.size() &lt; propertyPairs.size()) {</span>
<span class="fc" id="L399">        ProjectEmbeddingsNode node = new ProjectEmbeddingsNode(entry.getQueryPlan().getRoot(),</span>
          new ArrayList&lt;&gt;(updatedPropertyPairs));
<span class="fc" id="L401">        newTable.add(new PlanTableEntry(GRAPH,</span>
<span class="fc" id="L402">          Sets.newHashSet(entry.getProcessedVariables()), entry.getPredicates(),</span>
          new QueryPlanEstimator(new QueryPlan(node), queryHandler, graphStatistics)));
<span class="fc" id="L404">      } else {</span>
<span class="fc" id="L405">        newTable.add(entry);</span>
      }
<span class="fc" id="L407">    }</span>
<span class="fc" id="L408">    return newTable;</span>
  }

  //------------------------------------------------------------------------------------------------
  // Join and Expand
  //------------------------------------------------------------------------------------------------

  /**
   * Evaluates which entries in the specified plan table can be joined. The joined entries
   * are added to a new table which is returned.
   *
   * @param currentTable query plan table
   * @return new table containing solely joined plans from the input table
   */
  private PlanTable evaluateCartesianProducts(PlanTable currentTable) {
<span class="fc" id="L423">    PlanTable newTable = new PlanTable();</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">    for (int i = 0; i &lt; currentTable.size(); i++) {</span>
<span class="fc" id="L425">      PlanTableEntry leftEntry = currentTable.get(i);</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">      for (int j = i + 1; j &lt; currentTable.size(); j++) {</span>
<span class="fc" id="L427">        PlanTableEntry rightEntry = currentTable.get(j);</span>
<span class="fc" id="L428">        CNF joinPredicate = getJoinPredicate(leftEntry, rightEntry);</span>
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">        if (joinPredicate.size() &gt; 0) {</span>
<span class="fc" id="L430">          newTable.add(createValueJoinEntry(leftEntry, rightEntry, joinPredicate));</span>
        } else {
          // regular join or join with variable length path on source or target vertex
<span class="nc" id="L433">          newTable.add(createCartesianProductEntry(leftEntry, rightEntry));</span>
        }
      }
    }
<span class="fc" id="L437">    return newTable;</span>
  }


  /**
   * Computes the overlapping query variables of the specified entries.
   *
   * @param leftEntry first entry
   * @param rightEntry second entry
   * @return variables that are available in both input entries
   */
  private CNF getJoinPredicate(PlanTableEntry leftEntry, PlanTableEntry rightEntry) {
<span class="fc" id="L449">    Set&lt;String&gt; allVariables = leftEntry.getAllVariables();</span>
<span class="fc" id="L450">    allVariables.addAll(rightEntry.getAllVariables());</span>

<span class="fc" id="L452">    CNF leftPredicates = new CNF(leftEntry.getPredicates());</span>
<span class="fc" id="L453">    CNF rightPredicates = new CNF(rightEntry.getPredicates());</span>
<span class="fc" id="L454">    leftPredicates.removeSubCNF(rightEntry.getProcessedVariables());</span>
<span class="fc" id="L455">    rightPredicates.removeSubCNF(leftEntry.getProcessedVariables());</span>
<span class="fc" id="L456">    CNF predicates = leftPredicates.and(rightPredicates).getSubCNF(allVariables);</span>

<span class="fc" id="L458">    return new CNF(</span>
<span class="fc" id="L459">      predicates.getPredicates()</span>
<span class="fc" id="L460">        .stream()</span>
<span class="fc" id="L461">        .filter(p -&gt;</span>
<span class="pc bpc" id="L462" title="2 of 4 branches missed.">          p.size() == 1 &amp;&amp; p.getPredicates().get(0).getComparator().equals(Comparator.EQ)</span>
<span class="fc" id="L463">        ).collect(Collectors.toList())</span>
    );
  }

  /**
   * Creates an {@link CartesianProductNode} from the specified arguments.
   *
   * @param leftEntry left entry
   * @param rightEntry right entry
   *
   * @return new expand node
   */
  private PlanTableEntry createCartesianProductEntry(PlanTableEntry leftEntry,
    PlanTableEntry rightEntry) {
<span class="nc" id="L477">    CartesianProductNode node = new CartesianProductNode(</span>
<span class="nc" id="L478">      leftEntry.getQueryPlan().getRoot(),</span>
<span class="nc" id="L479">      rightEntry.getQueryPlan().getRoot(),</span>
      vertexStrategy, edgeStrategy
    );

<span class="nc" id="L483">    Set&lt;String&gt; processedVariables = leftEntry.getProcessedVariables();</span>
<span class="nc" id="L484">    processedVariables.addAll(rightEntry.getProcessedVariables());</span>

<span class="nc" id="L486">    CNF predicates = mergePredicates(leftEntry, rightEntry);</span>

<span class="nc" id="L488">    return new PlanTableEntry(</span>
      GRAPH,
      processedVariables,
      predicates,
      new QueryPlanEstimator(new QueryPlan(node), queryHandler, graphStatistics)
    );
  }

  /**
   * Creates an {@link ValueJoinNode} from the specified arguments.
   *
   * @param leftEntry left entry
   * @param rightEntry right entry
   * @param joinPredicate join predicate
   *
   * @return new value join node
   */
  private PlanTableEntry createValueJoinEntry(PlanTableEntry leftEntry,
    PlanTableEntry rightEntry, CNF joinPredicate) {

<span class="fc" id="L508">    List&lt;Pair&lt;String, String&gt;&gt; leftProperties = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L509">    List&lt;Pair&lt;String, String&gt;&gt; rightProperties = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L511" title="All 2 branches covered.">    for (CNFElement e : joinPredicate.getPredicates()) {</span>
<span class="fc" id="L512">      ComparisonExpression comparison = e.getPredicates().get(0);</span>

<span class="fc" id="L514">      Pair&lt;String, String&gt; joinProperty = extractJoinProperty(comparison.getLhs());</span>
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">      if (leftEntry.getAllVariables().contains(joinProperty.getKey())) {</span>
<span class="fc" id="L516">        leftProperties.add(joinProperty);</span>
      } else {
<span class="nc" id="L518">        rightProperties.add(joinProperty);</span>
      }

<span class="fc" id="L521">      joinProperty = extractJoinProperty(comparison.getRhs());</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">      if (leftEntry.getAllVariables().contains(joinProperty.getKey())) {</span>
<span class="nc" id="L523">        leftProperties.add(joinProperty);</span>
      } else {
<span class="fc" id="L525">        rightProperties.add(joinProperty);</span>
      }
<span class="fc" id="L527">    }</span>

<span class="fc" id="L529">    ValueJoinNode node = new ValueJoinNode(</span>
<span class="fc" id="L530">      leftEntry.getQueryPlan().getRoot(),</span>
<span class="fc" id="L531">      rightEntry.getQueryPlan().getRoot(),</span>
      leftProperties, rightProperties,
      vertexStrategy, edgeStrategy
    );

<span class="fc" id="L536">    Set&lt;String&gt; processedVariables = leftEntry.getProcessedVariables();</span>
<span class="fc" id="L537">    processedVariables.addAll(rightEntry.getProcessedVariables());</span>

<span class="fc" id="L539">    CNF predicates = mergePredicates(leftEntry, rightEntry);</span>

<span class="fc" id="L541">    return new PlanTableEntry(</span>
      GRAPH,
      processedVariables,
      predicates,
      new QueryPlanEstimator(new QueryPlan(node), queryHandler, graphStatistics)
    );
  }

  /**
   * Turns a QueryComparable into a {@code Pair&lt;Variable, PropertyKey&gt;}
   * @param comparable query comparable
   * @return join property
   */
  private Pair&lt;String, String&gt; extractJoinProperty(QueryComparable comparable) {
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">    if (comparable instanceof PropertySelectorComparable) {</span>
<span class="fc" id="L556">      PropertySelectorComparable propertySelector = (PropertySelectorComparable) comparable;</span>
<span class="fc" id="L557">      return Pair.of(propertySelector.getVariable(), propertySelector.getPropertyKey());</span>
    } else {
      //TODO #580 Include ElementSelector -&gt; ID needs to be projected as property
<span class="nc" id="L560">      throw new RuntimeException(&quot;Comparable &quot; + comparable + &quot;cant be used for ValueJoin&quot;);</span>
    }
  }

  /**
   * Creates a new predicate that includes only elements that exist in both input predicates
   *
   * @param leftEntry left side plant table entry
   * @param rightEntry right side plan table entry
   * @return Merged predicates
   */
  private CNF mergePredicates(PlanTableEntry leftEntry, PlanTableEntry rightEntry) {
<span class="fc" id="L572">    CNF leftPredicates = new CNF(leftEntry.getPredicates());</span>
<span class="fc" id="L573">    CNF rightPredicates = new CNF(rightEntry.getPredicates());</span>
<span class="fc" id="L574">    leftPredicates.removeSubCNF(rightEntry.getProcessedVariables());</span>
<span class="fc" id="L575">    rightPredicates.removeSubCNF(leftEntry.getProcessedVariables());</span>
<span class="fc" id="L576">    return leftPredicates.and(rightPredicates);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>