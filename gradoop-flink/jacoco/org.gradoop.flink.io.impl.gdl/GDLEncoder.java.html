<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GDLEncoder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Gradoop Flink</a> &gt; <a href="index.source.html" class="el_package">org.gradoop.flink.io.impl.gdl</a> &gt; <span class="el_source">GDLEncoder.java</span></div><h1>GDLEncoder.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2014 - 2019 Leipzig University (Database Research Group)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gradoop.flink.io.impl.gdl;

import org.gradoop.common.model.impl.id.GradoopId;
import org.gradoop.common.model.impl.pojo.Edge;
import org.gradoop.common.model.impl.pojo.GraphHead;
import org.gradoop.common.model.impl.pojo.Vertex;
import org.gradoop.common.model.impl.properties.Properties;
import org.gradoop.common.model.impl.properties.Property;
import org.gradoop.common.model.impl.properties.PropertyValue;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Encodes data structures using the GDL format.
 */
public class GDLEncoder {
  /**
   * Marks the beginning of the definition of vertices and edges.
   */
  private static final String GRAPH_ELEMENTS_DEFINITION_START = &quot;[&quot;;
  /**
   * Marks the end of the definition of vertices and edges.
   */
  private static final String GRAPH_ELEMENTS_DEFINITION_END = &quot;]&quot;;
  /**
   * graph variable prefix
   */
  private static final String GRAPH_VARIABLE_PREFIX = &quot;g&quot;;
  /**
   * vertex variable prefix
   */
  private static final String VERTEX_VARIABLE_PREFIX = &quot;v&quot;;
  /**
   * edge variable prefix
   */
  private static final String EDGE_VARIABLE_PREFIX = &quot;e&quot;;
  /**
   * Marks the end of the properties prefix.
   */
  private static final String PROPERTIES_PREFIX = &quot;{&quot;;
  /**
   * Marks the end of the properties string.
   */
  private static final String PROPERTIES_SUFFIX = &quot;}&quot;;
  /**
   * Separates properties.
   */
  private static final String PROPERTIES_SEPARATOR = &quot;,&quot;;
  /**
   * Separates key and value for properties.
   */
  private static final String KEY_VALUE_SEPARATOR = &quot;:&quot;;
  /**
   * Suffix for GDL double representation.
   */
  private static final String DOUBLE_SUFFIX = &quot;d&quot;;
  /**
   * Suffix for GDL float representation.
   */
  private static final String FLOAT_SUFFIX = &quot;f&quot;;
  /**
   * Suffix for GDL long representation.
   */
  private static final String LONG_SUFFIX = &quot;L&quot;;
  /**
   * GDL null representation.
   */
  private static final String NULL_STRING = &quot;NULL&quot;;
  /**
   * GDL string prefix
   */
  private static final String STRING_PREFIX = &quot;\&quot;&quot;;
  /**
   * GDL string suffix
   */
  private static final String STRING_SUFFIX = &quot;\&quot;&quot;;

  /**
   * Graph head to encode.
   */
  private List&lt;GraphHead&gt; graphHeads;
  /**
   * Vertices to encode.
   */
  private List&lt;Vertex&gt; vertices;
  /**
   * Edges to encode.
   */
  private List&lt;Edge&gt; edges;

  /**
   * Creates a GDLEncoder using the passed parameters.
   *
   * @param graphHeads graph head that should be encoded
   * @param vertices vertices that should be encoded
   * @param edges edges that should be encoded
   */
<span class="fc" id="L118">  public GDLEncoder(List&lt;GraphHead&gt; graphHeads, List&lt;Vertex&gt; vertices, List&lt;Edge&gt; edges) {</span>
<span class="fc" id="L119">    this.graphHeads = graphHeads;</span>
<span class="fc" id="L120">    this.vertices = vertices;</span>
<span class="fc" id="L121">    this.edges = edges;</span>
<span class="fc" id="L122">  }</span>

  /**
   * Creates a GDL formatted string from the graph heads, vertices and edges.
   *
   * @return GDL formatted string
   */
  public String getGDLString() {
<span class="fc" id="L130">    Map&lt;GradoopId, String&gt; idToGraphHeadName = getGraphHeadNameMapping(graphHeads);</span>
<span class="fc" id="L131">    Map&lt;GradoopId, String&gt; idToVertexName = getVertexNameMapping(vertices);</span>
<span class="fc" id="L132">    Map&lt;GradoopId, String&gt; idToEdgeName = getEdgeNameMapping(edges);</span>

<span class="fc" id="L134">    Set&lt;GradoopId&gt; usedVertexIds = new HashSet&lt;&gt;();</span>
<span class="fc" id="L135">    Set&lt;GradoopId&gt; usedEdgeIds = new HashSet&lt;&gt;();</span>

<span class="fc" id="L137">    StringBuilder result = new StringBuilder();</span>

<span class="fc bfc" id="L139" title="All 2 branches covered.">    for (GraphHead gh : graphHeads) {</span>
<span class="fc" id="L140">      StringBuilder verticesString = new StringBuilder();</span>
<span class="fc" id="L141">      StringBuilder edgesString = new StringBuilder();</span>

<span class="fc bfc" id="L143" title="All 2 branches covered.">      for (Vertex v : vertices) {</span>
<span class="fc" id="L144">        boolean containedInGraph = v.getGraphIds().contains(gh.getId());</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">        boolean firstOccurrence = !usedVertexIds.contains(v.getId());</span>

<span class="fc bfc" id="L147" title="All 4 branches covered.">        if (containedInGraph &amp;&amp; firstOccurrence) {</span>
<span class="fc" id="L148">          String vertexString = vertexToGDLString(v, idToVertexName);</span>
<span class="fc" id="L149">          usedVertexIds.add(v.getId());</span>
<span class="fc" id="L150">          verticesString.append(vertexString).append(System.lineSeparator());</span>
        }
<span class="fc" id="L152">      }</span>

<span class="fc bfc" id="L154" title="All 2 branches covered.">      for (Edge e : edges) {</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">        if (e.getGraphIds().contains(gh.getId())) {</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">          boolean firstOccurrence = !usedEdgeIds.contains(e.getId());</span>
<span class="fc" id="L157">          String edgeString = edgeToGDLString(e, idToVertexName, idToEdgeName, firstOccurrence);</span>
<span class="fc" id="L158">          usedEdgeIds.add(e.getId());</span>
<span class="fc" id="L159">          edgesString.append(edgeString).append(System.lineSeparator());</span>
        }
<span class="fc" id="L161">      }</span>

<span class="fc" id="L163">      result</span>
<span class="fc" id="L164">        .append(graphHeadToGDLString(gh, idToGraphHeadName))</span>
<span class="fc" id="L165">        .append(GRAPH_ELEMENTS_DEFINITION_START).append(System.lineSeparator())</span>
<span class="fc" id="L166">        .append(verticesString).append(System.lineSeparator())</span>
<span class="fc" id="L167">        .append(edgesString)</span>
<span class="fc" id="L168">        .append(GRAPH_ELEMENTS_DEFINITION_END)</span>
<span class="fc" id="L169">        .append(System.lineSeparator()).append(System.lineSeparator());</span>
<span class="fc" id="L170">    }</span>
<span class="fc" id="L171">    return result.toString();</span>
  }

  /**
   * Returns a mapping between the graph heads gradoop ids and the GDL variable names.
   *
   * @param graphHeads The graph heads.
   * @return Mapping between graph head and GDL variable name.
   */
  private Map&lt;GradoopId, String&gt; getGraphHeadNameMapping(List&lt;GraphHead&gt; graphHeads) {
<span class="fc" id="L181">    Map&lt;GradoopId, String&gt; idToGraphHeadName = new HashMap&lt;&gt;(graphHeads.size());</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">    for (int i = 0; i &lt; graphHeads.size(); i++) {</span>
<span class="fc" id="L183">      GraphHead g = graphHeads.get(i);</span>
<span class="fc" id="L184">      String gName = String.format(&quot;%s%s&quot;, GRAPH_VARIABLE_PREFIX, i);</span>
<span class="fc" id="L185">      idToGraphHeadName.put(g.getId(), gName);</span>
    }
<span class="fc" id="L187">    return idToGraphHeadName;</span>
  }

  /**
   * Returns a mapping between the vertex GradoopID and the GDL variable name.
   *
   * @param vertices The graph vertices.
   * @return Mapping between vertex and GDL variable name.
   */
  private Map&lt;GradoopId, String&gt; getVertexNameMapping(List&lt;Vertex&gt; vertices) {
<span class="fc" id="L197">    Map&lt;GradoopId, String&gt; idToVertexName = new HashMap&lt;&gt;(vertices.size());</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">    for (int i = 0; i &lt; vertices.size(); i++) {</span>
<span class="fc" id="L199">      Vertex v = vertices.get(i);</span>
<span class="fc" id="L200">      String vName = String.format(&quot;%s_%s_%s&quot;, VERTEX_VARIABLE_PREFIX, v.getLabel(), i);</span>
<span class="fc" id="L201">      idToVertexName.put(v.getId(), vName);</span>
    }
<span class="fc" id="L203">    return idToVertexName;</span>
  }

  /**
   * Returns a mapping between the edge GradoopId and the GDL variable name.
   *
   * @param edges The graph edges.
   * @return Mapping between edge and GDL variable name.
   */
  private Map&lt;GradoopId, String&gt; getEdgeNameMapping(List&lt;Edge&gt; edges) {
<span class="fc" id="L213">    Map&lt;GradoopId, String&gt; idToEdgeName = new HashMap&lt;&gt;(edges.size());</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">    for (int i = 0; i &lt; edges.size(); i++) {</span>
<span class="fc" id="L215">      Edge e = edges.get(i);</span>
<span class="fc" id="L216">      String eName = String.format(&quot;%s_%s_%s&quot;, EDGE_VARIABLE_PREFIX, e.getLabel(), i);</span>
<span class="fc" id="L217">      idToEdgeName.put(e.getId(), eName);</span>
    }
<span class="fc" id="L219">    return idToEdgeName;</span>
  }

  /**
   * Returns a GDL formatted graph head string.
   *
   * @param g graph head
   * @param idToGraphHeadName mapping from graph head id to its GDL variable name
   * @return GDL formatted string
   */
  private String graphHeadToGDLString(GraphHead g, Map&lt;GradoopId, String&gt; idToGraphHeadName) {
<span class="fc" id="L230">    return String.format(&quot;%s:%s %s&quot;,</span>
<span class="fc" id="L231">      idToGraphHeadName.get(g.getId()),</span>
<span class="fc" id="L232">      g.getLabel(),</span>
<span class="fc" id="L233">      propertiesToGDLString(g.getProperties()));</span>
  }

  /**
   * Returns the gdl formatted vertex including the properties and the label on first occurrence
   * or otherwise just the variable name.
   *
   * @param v The vertex that should be formatted.
   * @param idToVertexName Maps GradoopId of a vertex to a string that represents the gdl
   *                       variable name
   * @return A GDL formatted vertex string.
   */
  private String vertexToGDLString(Vertex v, Map&lt;GradoopId, String&gt; idToVertexName)  {
<span class="fc" id="L246">    return String.format(&quot;(%s:%s %s)&quot;,</span>
<span class="fc" id="L247">      idToVertexName.get(v.getId()),</span>
<span class="fc" id="L248">      v.getLabel(),</span>
<span class="fc" id="L249">      propertiesToGDLString(v.getProperties()));</span>
  }

  /**
   * Returns the GDL formatted edge, including the properties and the label on first occurrence
   * or otherwise just the variable name.
   *
   * @param e The edge to be formatted.
   * @param idToVertexName Maps GradoopId of a vertex to a string that represents the GDL
   *                       variable name
   * @param idToEdgeName Maps GradoopId of an edge to a string that represents the GDL variable
   *                     name.
   * @param firstOccurrence Is it the first occurrence of the vertex in all graphs?
   * @return A GDL formatted edge string.
   */
  private String edgeToGDLString(
    Edge e,
    Map&lt;GradoopId, String&gt; idToVertexName,
    Map&lt;GradoopId, String&gt; idToEdgeName,
    boolean firstOccurrence) {
    String result;
<span class="fc bfc" id="L270" title="All 2 branches covered.">    if (firstOccurrence) {</span>
<span class="fc" id="L271">      result =  String.format(&quot;(%s)-[%s:%s%s]-&gt;(%s)&quot;,</span>
<span class="fc" id="L272">        idToVertexName.get(e.getSourceId()),</span>
<span class="fc" id="L273">        idToEdgeName.get(e.getId()),</span>
<span class="fc" id="L274">        e.getLabel(),</span>
<span class="fc" id="L275">        propertiesToGDLString(e.getProperties()),</span>
<span class="fc" id="L276">        idToVertexName.get(e.getTargetId()));</span>
    } else {
<span class="fc" id="L278">      result = String.format(&quot;(%s)-[%s]-&gt;(%s)&quot;,</span>
<span class="fc" id="L279">        idToVertexName.get(e.getSourceId()),</span>
<span class="fc" id="L280">        idToEdgeName.get(e.getId()),</span>
<span class="fc" id="L281">        idToVertexName.get(e.getTargetId()));</span>
    }
<span class="fc" id="L283">    return result;</span>
  }

  /**
   * Returns the properties as a GDL formatted String.
   *
   * @param properties The properties to be formatted.
   * @return A GDL formatted string that represents the properties.
   */
  private String propertiesToGDLString(Properties properties) {
<span class="pc bpc" id="L293" title="1 of 4 branches missed.">    if (properties == null || properties.isEmpty()) {</span>
<span class="fc" id="L294">      return &quot;&quot;;</span>
    } else {
<span class="fc" id="L296">      return properties.toList().stream()</span>
<span class="fc" id="L297">        .map(this::propertyToGDLString)</span>
<span class="fc" id="L298">        .collect(Collectors.joining(PROPERTIES_SEPARATOR, PROPERTIES_PREFIX, PROPERTIES_SUFFIX));</span>
    }
  }

  /**
   * Returns this property as a GDL formatted String.
   *
   * @param property The property.
   * @return A GDL formatted string that represents the property.
   */
  private String propertyToGDLString(Property property) {
<span class="fc" id="L309">    StringBuilder result = new StringBuilder()</span>
<span class="fc" id="L310">      .append(property.getKey())</span>
<span class="fc" id="L311">      .append(KEY_VALUE_SEPARATOR);</span>

<span class="fc" id="L313">    PropertyValue value = property.getValue();</span>

<span class="fc bfc" id="L315" title="All 2 branches covered.">    if (value.isString()) {</span>
<span class="fc" id="L316">      result.append(STRING_PREFIX).append(value.toString()).append(STRING_SUFFIX);</span>
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">    } else if (value.isNull()) {</span>
<span class="nc" id="L318">      result.append(NULL_STRING);</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">    } else if (value.isDouble()) {</span>
<span class="nc" id="L320">      result.append(value.toString()).append(DOUBLE_SUFFIX);</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">    } else if (value.isFloat()) {</span>
<span class="nc" id="L322">      result.append(value.toString()).append(FLOAT_SUFFIX);</span>
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">    } else if (value.isLong()) {</span>
<span class="nc" id="L324">      result.append(value.toString()).append(LONG_SUFFIX);</span>
    } else {
<span class="fc" id="L326">      result.append(value.toString());</span>
    }

<span class="fc" id="L329">    return result.toString();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>