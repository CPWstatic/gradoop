<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HBaseFilterUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Gradoop HBase</a> &gt; <a href="index.source.html" class="el_package">org.gradoop.storage.impl.hbase.predicate.filter</a> &gt; <span class="el_source">HBaseFilterUtils.java</span></div><h1>HBaseFilterUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2014 - 2019 Leipzig University (Database Research Group)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gradoop.storage.impl.hbase.predicate.filter;

import org.apache.hadoop.hbase.filter.BinaryComparator;
import org.apache.hadoop.hbase.filter.CompareFilter;
import org.apache.hadoop.hbase.filter.Filter;
import org.apache.hadoop.hbase.filter.FilterList;
import org.apache.hadoop.hbase.filter.RegexStringComparator;
import org.apache.hadoop.hbase.filter.RowFilter;
import org.apache.hadoop.hbase.filter.SingleColumnValueFilter;
import org.apache.hadoop.hbase.filter.FuzzyRowFilter;
import org.apache.hadoop.hbase.util.Bytes;
import org.apache.hadoop.hbase.util.Pair;
import org.gradoop.common.model.impl.id.GradoopId;
import org.gradoop.common.model.impl.id.GradoopIdSet;
import org.gradoop.common.model.impl.properties.PropertyValue;
import org.gradoop.common.model.impl.properties.PropertyValueUtils;

import javax.annotation.Nonnull;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;

import static org.gradoop.storage.impl.hbase.constants.HBaseConstants.CF_META;
import static org.gradoop.storage.impl.hbase.constants.HBaseConstants.CF_PROPERTY_VALUE;
import static org.gradoop.storage.impl.hbase.constants.HBaseConstants.CF_PROPERTY_TYPE;
import static org.gradoop.storage.impl.hbase.constants.HBaseConstants.COL_LABEL;

/**
 * Utility class for common HBase filter tasks
 */
<span class="nc" id="L47">public class HBaseFilterUtils {</span>
  /**
   * Byte representation of meta data column family
   */
<span class="fc" id="L51">  private static final byte[] CF_META_BYTES = Bytes.toBytesBinary(CF_META);</span>
  /**
   * Byte representation of property value column family
   */
<span class="fc" id="L55">  private static final byte[] CF_PROPERTY_VALUE_BYTES = Bytes.toBytesBinary(CF_PROPERTY_VALUE);</span>
  /**
   * Byte representation of property type column family
   */
<span class="fc" id="L59">  private static final byte[] CF_PROPERTY_TYPE_BYTES = Bytes.toBytesBinary(CF_PROPERTY_TYPE);</span>
  /**
   * Byte representation of column qualifier
   */
<span class="fc" id="L63">  private static final byte[] COL_LABEL_BYTES = Bytes.toBytesBinary(COL_LABEL);</span>

  /**
   * Creates a HBase Filter object to return only graph elements that are equal to the given
   * GradoopIds.
   *
   * @param elementIds a set of graph element GradoopIds to filter
   * @param isSpreadingByteUsed indicates if the handlers using a spreading byte as prefix
   *                            of each row key
   * @return a HBase Filter object
   */
  public static Filter getIdFilter(GradoopIdSet elementIds, boolean isSpreadingByteUsed) {
    Filter filter;
<span class="fc bfc" id="L76" title="All 2 branches covered.">    if (isSpreadingByteUsed) {</span>
      // a spreading byte is used as prefix in row key, therefore a FuzzyRowFilter has to be used
<span class="fc" id="L78">      byte[] dummyByte = new byte[1];</span>

      // instantiate a list of byte array pairs for the fuzzy row filter
<span class="fc" id="L81">      List&lt;Pair&lt;byte[], byte[]&gt;&gt; fuzzyList = new ArrayList&lt;&gt;();</span>

      // create a byte array and set the first to '1' to identify the position of dynamic bytes
<span class="fc" id="L84">      byte[] fuzzyInfo = new byte[13];</span>
<span class="fc" id="L85">      fuzzyInfo[0] = (byte) 1;</span>

<span class="fc bfc" id="L87" title="All 2 branches covered.">      for (GradoopId gradoopId : elementIds) {</span>
        // for each id create a 13 byte long array from a dummy byte and the 12 byte gradoop id
<span class="fc" id="L89">        byte[] rowKey = Bytes.add(dummyByte, gradoopId.toByteArray());</span>
<span class="fc" id="L90">        fuzzyList.add(new Pair&lt;&gt;(rowKey, fuzzyInfo));</span>
<span class="fc" id="L91">      }</span>
<span class="fc" id="L92">      filter = new FuzzyRowFilter(fuzzyList);</span>
<span class="fc" id="L93">    } else {</span>
      // no spreading byte in row key, therefore a list of RowFilters has to be used

<span class="fc" id="L96">      FilterList filterList = new FilterList(FilterList.Operator.MUST_PASS_ONE);</span>

<span class="fc bfc" id="L98" title="All 2 branches covered.">      for (GradoopId gradoopId : elementIds) {</span>
<span class="fc" id="L99">        RowFilter rowFilter = new RowFilter(</span>
          CompareFilter.CompareOp.EQUAL,
<span class="fc" id="L101">          new BinaryComparator(gradoopId.toByteArray())</span>
        );
<span class="fc" id="L103">        filterList.addFilter(rowFilter);</span>
<span class="fc" id="L104">      }</span>
<span class="fc" id="L105">      filter = filterList;</span>
    }
<span class="fc" id="L107">    return filter;</span>
  }

  /**
   * Creates a HBase Filter object representation of labelIn predicate
   *
   * @param labels set of labels to filter for
   * @param negate flag to define if this filter should be negated
   * @return the HBase filter representation
   */
  public static Filter getLabelInFilter(@Nonnull Set&lt;String&gt; labels, boolean negate) {
    // Handle negation
<span class="fc bfc" id="L119" title="All 2 branches covered.">    CompareFilter.CompareOp compareOp = negate ? CompareFilter.CompareOp.NOT_EQUAL :</span>
      CompareFilter.CompareOp.EQUAL;
<span class="fc bfc" id="L121" title="All 2 branches covered.">    FilterList.Operator listOperator = negate ? FilterList.Operator.MUST_PASS_ALL :</span>
      FilterList.Operator.MUST_PASS_ONE;

<span class="fc" id="L124">    FilterList filterList = new FilterList(listOperator);</span>

<span class="fc" id="L126">    labels.stream()</span>
<span class="fc" id="L127">      .map(label -&gt; new SingleColumnValueFilter(CF_META_BYTES, COL_LABEL_BYTES, compareOp,</span>
<span class="fc" id="L128">        Bytes.toBytesBinary(label)))</span>
<span class="fc" id="L129">      .forEach(filterList::addFilter);</span>

<span class="fc" id="L131">    return filterList;</span>
  }

  /**
   * Creates a HBase Filter object representation of labelReg predicate
   *
   * @param reg the pattern to filter for
   * @param negate flag to define if this filter should be negated
   * @return the HBase filter representation
   */
  public static Filter getLabelRegFilter(@Nonnull Pattern reg, boolean negate) {
<span class="fc bfc" id="L142" title="All 2 branches covered.">    return new SingleColumnValueFilter(</span>
      CF_META_BYTES,
      COL_LABEL_BYTES,
      negate ? CompareFilter.CompareOp.NOT_EQUAL : CompareFilter.CompareOp.EQUAL,
<span class="fc" id="L146">      new RegexStringComparator(reg.pattern())</span>
    );
  }

  /**
   * Creates a HBase Filter object representation of propEquals predicate
   *
   * @param key the property key to filter for
   * @param value the value to filter for
   * @param negate flag to define if this filter should be negated
   * @return the HBase filter representation
   */
  public static Filter getPropEqualsFilter(@Nonnull String key, @Nonnull PropertyValue value,
    boolean negate) {
    // Handle negation
<span class="fc bfc" id="L161" title="All 2 branches covered.">    CompareFilter.CompareOp compareOp = negate ? CompareFilter.CompareOp.NOT_EQUAL :</span>
      CompareFilter.CompareOp.EQUAL;
<span class="fc bfc" id="L163" title="All 2 branches covered.">    FilterList.Operator listOperator = negate ? FilterList.Operator.MUST_PASS_ONE :</span>
      FilterList.Operator.MUST_PASS_ALL;

<span class="fc" id="L166">    FilterList filterList = new FilterList(listOperator);</span>

<span class="fc" id="L168">    SingleColumnValueFilter valueFilter = new SingleColumnValueFilter(</span>
      CF_PROPERTY_VALUE_BYTES,
<span class="fc" id="L170">      Bytes.toBytesBinary(key),</span>
      compareOp,
<span class="fc" id="L172">      PropertyValueUtils.Bytes.getRawBytesWithoutType(value));</span>

    // Define that the entire row will be skipped if the column is not found
<span class="fc" id="L175">    valueFilter.setFilterIfMissing(true);</span>

<span class="fc" id="L177">    SingleColumnValueFilter typeFilter = new SingleColumnValueFilter(</span>
      CF_PROPERTY_TYPE_BYTES,
<span class="fc" id="L179">      Bytes.toBytesBinary(key),</span>
      compareOp,
<span class="fc" id="L181">      PropertyValueUtils.Bytes.getTypeByte(value));</span>

    // Define that the entire row will be skipped if the column is not found
<span class="fc" id="L184">    typeFilter.setFilterIfMissing(true);</span>

<span class="fc" id="L186">    filterList.addFilter(valueFilter);</span>
<span class="fc" id="L187">    filterList.addFilter(typeFilter);</span>
<span class="fc" id="L188">    return filterList;</span>
  }

  /**
   * Creates a HBase Filter object representation of propReg predicate
   *
   * @param key the property key to filter for
   * @param reg the pattern to search for
   * @param negate flag to define if this filter should be negated
   * @return the HBase filter representation
   */
  public static Filter getPropRegFilter(@Nonnull String key, @Nonnull Pattern reg, boolean negate) {
    // Handle negation
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">    CompareFilter.CompareOp compareOp = negate ? CompareFilter.CompareOp.NOT_EQUAL :</span>
      CompareFilter.CompareOp.EQUAL;
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">    FilterList.Operator listOperator = negate ? FilterList.Operator.MUST_PASS_ONE :</span>
      FilterList.Operator.MUST_PASS_ALL;

<span class="fc" id="L206">    FilterList filterList = new FilterList(listOperator);</span>

<span class="fc" id="L208">    SingleColumnValueFilter valueFilter = new SingleColumnValueFilter(</span>
      CF_PROPERTY_VALUE_BYTES,
<span class="fc" id="L210">      Bytes.toBytesBinary(key),</span>
      compareOp,
<span class="fc" id="L212">      new RegexStringComparator(reg.pattern()));</span>

    // Define that the entire row will be skipped if the column is not found
<span class="fc" id="L215">    valueFilter.setFilterIfMissing(true);</span>

<span class="fc" id="L217">    SingleColumnValueFilter typeFilter = new SingleColumnValueFilter(</span>
      CF_PROPERTY_TYPE_BYTES,
<span class="fc" id="L219">      Bytes.toBytesBinary(key),</span>
      compareOp,
      new byte[] {PropertyValue.TYPE_STRING});

    // Define that the entire row will be skipped if the column is not found
<span class="fc" id="L224">    typeFilter.setFilterIfMissing(true);</span>

<span class="fc" id="L226">    filterList.addFilter(typeFilter);</span>
<span class="fc" id="L227">    filterList.addFilter(valueFilter);</span>
<span class="fc" id="L228">    return filterList;</span>
  }

  /**
   * Creates a HBase Filter object representation of propLargerThan predicate
   *
   * @param key the property key to filter for
   * @param min the property value that defines the minimum of the filter
   * @param include a flag to define if a value that is equal to min should be included
   * @param negate flag to define if this filter should be negated
   * @return the HBase filter representation
   */
  public static Filter getPropLargerThanFilter(@Nonnull String key, @Nonnull PropertyValue min,
    boolean include, boolean negate) {
    // Handle negation
<span class="fc bfc" id="L243" title="All 2 branches covered.">    FilterList.Operator listOperator = negate ? FilterList.Operator.MUST_PASS_ONE :</span>
      FilterList.Operator.MUST_PASS_ALL;

    CompareFilter.CompareOp compareOp;
<span class="fc bfc" id="L247" title="All 2 branches covered.">    if (include) {</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">      if (negate) {</span>
<span class="fc" id="L249">        compareOp = CompareFilter.CompareOp.LESS;</span>
      } else {
<span class="fc" id="L251">        compareOp = CompareFilter.CompareOp.GREATER_OR_EQUAL;</span>
      }
    } else {
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">      if (negate) {</span>
<span class="nc" id="L255">        compareOp = CompareFilter.CompareOp.LESS_OR_EQUAL;</span>
      } else {
<span class="fc" id="L257">        compareOp = CompareFilter.CompareOp.GREATER;</span>
      }
    }

<span class="fc" id="L261">    FilterList filterList = new FilterList(listOperator);</span>

<span class="fc" id="L263">    SingleColumnValueFilter valueFilter = new SingleColumnValueFilter(</span>
      CF_PROPERTY_VALUE_BYTES,
<span class="fc" id="L265">      Bytes.toBytesBinary(key),</span>
      compareOp,
<span class="fc" id="L267">      new BinaryComparator(PropertyValueUtils.Bytes.getRawBytesWithoutType(min)));</span>

    // Define that the entire row will be skipped if the column is not found
<span class="fc" id="L270">    valueFilter.setFilterIfMissing(true);</span>

<span class="fc" id="L272">    SingleColumnValueFilter typeFilter = new SingleColumnValueFilter(</span>
      CF_PROPERTY_TYPE_BYTES,
<span class="fc bfc" id="L274" title="All 2 branches covered.">      Bytes.toBytesBinary(key),</span>
      negate ? CompareFilter.CompareOp.NOT_EQUAL : CompareFilter.CompareOp.EQUAL,
<span class="fc" id="L276">      PropertyValueUtils.Bytes.getTypeByte(min));</span>

    // Define that the entire row will be skipped if the column is not found
<span class="fc" id="L279">    typeFilter.setFilterIfMissing(true);</span>

<span class="fc" id="L281">    filterList.addFilter(valueFilter);</span>
<span class="fc" id="L282">    filterList.addFilter(typeFilter);</span>
<span class="fc" id="L283">    return filterList;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>